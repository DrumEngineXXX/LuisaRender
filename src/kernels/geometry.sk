#include <core/geometry.h>

using namespace luisa;
using namespace luisa::geometry;

LUISA_KERNEL void evaluate_interactions(
    LUISA_DEVICE_SPACE const uint &ray_count,
    LUISA_DEVICE_SPACE const Ray *ray_buffer,
    LUISA_DEVICE_SPACE const ClosestHit *hit_buffer,
    LUISA_DEVICE_SPACE const float3 *position_buffer,
    LUISA_DEVICE_SPACE const float3 *normal_buffer,
    LUISA_DEVICE_SPACE const float2 *uv_buffer,
    LUISA_DEVICE_SPACE const packed_uint3 *index_buffer,
    LUISA_DEVICE_SPACE const uint *vertex_offset_buffer,
    LUISA_DEVICE_SPACE const uint *index_offset_buffer,
    LUISA_DEVICE_SPACE const float4x4 *transform_buffer,
    LUISA_DEVICE_SPACE uint8_t *interaction_state_buffer,
    LUISA_DEVICE_SPACE float3 *interaction_position_buffer,
    LUISA_DEVICE_SPACE float3 *interaction_normal_buffer,
    LUISA_DEVICE_SPACE float2 *interaction_uv_buffer,
    LUISA_DEVICE_SPACE float4 *interaction_wo_and_pdf_buffer,
    LUISA_DEVICE_SPACE uint *interaction_instance_id_buffer,
    LUISA_UNIFORM_SPACE EvaluateInteractionsKernelUniforms &uniforms,
    LUISA_THREAD_ID_DECL) noexcept {
    
    if (auto tid = LUISA_THREAD_ID; tid < ray_count) {
        
        auto hit = hit_buffer[tid];
        if (hit.distance <= 0.0f) {
            interaction_state_buffer[tid] = interaction::state::MISS;
            return;
        }
        
        auto instance_index = static_cast<uint>(hit.instance_index);
        uint8_t state_flags = interaction::state::HIT;
        if ((static_cast<uint>(instance_index >= uniforms.static_shape_light_begin) & static_cast<uint>(instance_index < uniforms.static_shape_light_end)) |
            (static_cast<uint>(instance_index >= uniforms.dynamic_shape_light_begin) & static_cast<uint>(instance_index < uniforms.dynamic_shape_light_end)) |
            (static_cast<uint>(instance_index >= uniforms.static_instance_light_begin) & static_cast<uint>(instance_index < uniforms.static_instance_light_end)) |
            (static_cast<uint>(instance_index >= uniforms.dynamic_instance_light_begin) & static_cast<uint>(instance_index < uniforms.dynamic_instance_light_end))) {
            state_flags |= interaction::state::EMISSIVE;
        }
        
        auto indices = index_buffer[hit.triangle_index + index_offset_buffer[instance_index]] + vertex_offset_buffer[instance_index];
        
        using namespace interaction::attribute;
        auto attribute_flags = uniforms.attribute_flags;
        
        if (attribute_flags & INSTANCE_ID) { interaction_instance_id_buffer[tid] = instance_index; }
        
        if ((attribute_flags & POSITION) || (attribute_flags & NORMAL) || (attribute_flags & WO_AND_PDF)) {
            
            auto transform = transform_buffer[instance_index];
            auto normal_transform = transpose(inverse(make_float3x3(transform)));
            auto n = hit.bary_u * normal_buffer[indices.x] + hit.bary_v * normal_buffer[indices.y] + (1.0f - hit.bary_u - hit.bary_v) * normal_buffer[indices.z];
            auto normal = normalize(normal_transform * n);
            
            if (attribute_flags & POSITION) {
                auto p0 = position_buffer[indices.x];
                auto p1 = position_buffer[indices.y];
                auto p2 = position_buffer[indices.z];
                auto p = hit.bary_u * p0 + hit.bary_v * p1 + (1.0f - hit.bary_u - hit.bary_v) * p2;
                auto position = offset_ray_origin(make_float3(transform * make_float4(p, 1.0f)), normalize(normal_transform * math::cross(p1 - p0, p2 - p0)));
                interaction_position_buffer[tid] = position;
            }
            
            if (attribute_flags & NORMAL) { interaction_normal_buffer[tid] = normal; }
            
            if (attribute_flags & WO_AND_PDF) {
                auto wo = make_float3(-ray_buffer[tid].direction);
                auto distance = max(hit.distance, 1e-3f);
                auto cos_theta = dot(wo, normal);
                if (cos_theta <= 0.0f) { state_flags |= interaction::state::BACK_FACE; }  // assumed that all faces have an out-pointing normal
                auto pdf = abs(cos_theta) / (distance * distance);
                interaction_wo_and_pdf_buffer[tid] = make_float4(wo, pdf);
            }
        }
        
        if (attribute_flags & UV) {
            auto uv = hit.bary_u * uv_buffer[indices.x] + hit.bary_v * uv_buffer[indices.y] + (1.0f - hit.bary_u - hit.bary_v) * uv_buffer[indices.z];
            interaction_uv_buffer[tid] = uv;
        }
        
        interaction_state_buffer[tid] = state_flags;
    }
}
