#include <samplers/independent.h>

using namespace luisa;
using namespace luisa::sampler::independent;

template<uint N>
LUISA_DEVICE_CALLABLE inline uint tea(uint v0, uint v1) {
    auto s0 = 0u;
    for (auto n = 0u; n < N; n++) {
        s0 += 0x9e3779b9u;
        v0 += ((v1 << 4u) + 0xa341316cu) ^ (v1 + s0) ^ ((v1 >> 5u) + 0xc8013ea4u);
        v1 += ((v0 << 4u) + 0xad90777du) ^ (v0 + s0) ^ ((v0 >> 5u) + 0x7e95761eu);
    }
    return v0;
}

LUISA_DEVICE_CALLABLE inline uint lcg(LUISA_THREAD_SPACE uint &prev) {
    constexpr auto LCG_A = 1664525u;
    constexpr auto LCG_C = 1013904223u;
    prev = (LCG_A * prev + LCG_C);
    return prev & 0x00ffffffu;
}

LUISA_DEVICE_CALLABLE inline float rnd(LUISA_THREAD_SPACE unsigned int &prev) {
    constexpr auto inv = 1.0f / static_cast<float>(0x01000000);
    return static_cast<float>(lcg(prev)) * inv;
}

LUISA_KERNEL void reset_states(
    LUISA_UNIFORM_SPACE Viewport &film_viewport,
    LUISA_DEVICE_SPACE State *sampler_state_buffer,
    LUISA_THREAD_ID_DECL) {
    
    auto tid = LUISA_THREAD_ID;
    if (tid < film_viewport.size.x * film_viewport.size.y) {
        auto pixel_x = tid % film_viewport.size.x + film_viewport.origin.x;
        auto pixel_y = tid / film_viewport.size.x + film_viewport.origin.y;
        sampler_state_buffer[tid] = tea<4>(pixel_x, pixel_y);
    }
    
}

LUISA_KERNEL void generate_samples(
    LUISA_DEVICE_SPACE State *sampler_state_buffer,
    LUISA_DEVICE_SPACE const uint *ray_queue,
    LUISA_DEVICE_SPACE const uint &ray_count,
    LUISA_DEVICE_SPACE float *sample_buffer,
    LUISA_UNIFORM_SPACE GenerateSamplesKernelUniforms &uniforms,
    LUISA_THREAD_ID_DECL) {
    
    auto max_ray_count = uniforms.uses_ray_queue ? ray_count : uniforms.tile_viewport.size.x * uniforms.tile_viewport.size.y;
    
    auto tid = LUISA_THREAD_ID;
    if (tid < max_ray_count) {
        auto ray_index_in_tile = uniforms.uses_ray_queue ? ray_queue[tid] : tid;
        auto ray_x = uniforms.tile_viewport.origin.x + ray_index_in_tile % uniforms.tile_viewport.size.x;
        auto ray_y = uniforms.tile_viewport.origin.y + ray_index_in_tile / uniforms.tile_viewport.size.x;
        auto ray_index = ray_y * uniforms.film_viewport.size.x + ray_x;
        auto state = sampler_state_buffer[ray_index];
        switch (uniforms.num_dimensions) {
            case 1:
                sample_buffer[tid] = rnd(state);
                break;
            case 2:
                sample_buffer[tid * 2] = rnd(state);
                sample_buffer[tid * 2 + 1] = rnd(state);
                break;
            case 3:
                sample_buffer[tid * 3] = rnd(state);
                sample_buffer[tid * 3 + 1] = rnd(state);
                sample_buffer[tid * 3 + 2] = rnd(state);
                break;
            case 4:
                sample_buffer[tid * 4] = rnd(state);
                sample_buffer[tid * 4 + 1] = rnd(state);
                sample_buffer[tid * 4 + 2] = rnd(state);
                sample_buffer[tid * 4 + 3] = rnd(state);
                break;
            default:
                break;
        }
        sampler_state_buffer[ray_index] = state;
    }
}
